from typing import Any, Callable\\nimport requests\\n\\nfrom py3xui.utils import Logger\\n\\nlogger = Logger(__name__)\\n\\n# pylint: disable=too-few-public-methods\\nclass ApiFields:\\n    \"\"\"Stores the fields returned by the XUI API for parsing.\"\"\"\\n    SUCCESS = "success"\\n    MSG = "msg"\\n    OBJ = "obj"\\n    CLIENT_STATS = "clientStats"\\n    NO_IP_RECORD = "No IP Record"\\n\\nclass BaseApi:\\n    def __init__(self, host: str, username: str, password: str):\\n        self._host = host.rstrip("/")\\n        self._username = username\\n        self._password = password\\n        self._max_retries = 3\\n        self._session = None\\n\\n    @property\\n    def host(self) -> str:\\n        return self._host\\n\\n    @property\\n    def username(self) -> str:\\n        return self._username\\n\\n    @property\\n    def password(self) -> str:\\n        return self._password\\n\\n    @property\\n    def max_retries(self) -> int:\\n        return self._max_retries\\n\\n    @max_retries.setter\\n    def max_retries(self, value: int) -> None:\\n        self._max_retries = value\\n\\n    @property\\n    def session(self) -> str | None:\\n        return self._session\\n\\n    @session.setter\\n    def session(self, value: str | None) -> None:\\n        self._session = value\\n\\n    def login(self) -> None:\\n        endpoint = "login"\\n        headers = {} \\n        url = self._url(endpoint) \\n        data = {"username": self.username, "password": self.password} \\n        logger.info("Logging in with username: %s", self.username) \\n        response = self._post(url, headers, data) \\n        cookie = response.cookies.get("session") \\n        if not cookie:\\n            raise ValueError("No session cookie found, something wrong with the login...") \\n        logger.info("Session cookie successfully retrieved for username: %s", self.username) \\n        self.session = cookie\\n\\n    def _check_response(self, response: requests.Response) -> None:\\n        response_json = response.json()\\n        status = response_json.get(ApiFields.SUCCESS) \\n        message = response_json.get(ApiFields.MSG) \\n        if not status:\\n            raise ValueError(f"Response status is not successful, message: {message}") \\n\\n    def _url(self, endpoint: str) -> str:\\n        return f"{{self._host}}/{endpoint}"\\n\\n    def _request_with_retry(self, method: Callable[..., requests.Response], url: str, headers: dict[str, str], **kwargs: Any) -> requests.Response:\\n        logger.debug("%s request to %s...", method.__name__.upper(), url) \\n        for retry in range(1, self.max_retries + 1): \\n            try:\\n                skip_check = kwargs.pop("skip_check", False) \\n                response = method(url, cookies={"session": self.session}, headers=headers, **kwargs) \\n                response.raise_for_status() \\n                if skip_check:\\n                    return response \\n                self._check_response(response) \\n                return response \\n            except (requests.exceptions.ConnectionError, requests.exceptions.Timeout) as e:\\n                if retry == self.max_retries:\\n                    raise e \\n                logger.warning("Request to %s failed: %s, retry %s of %s", url, e, retry, self.max_retries) \\n                time.sleep(1 * (retry + 1)) \\n            except requests.exceptions.RequestException as e:\\n                raise e \\n        raise requests.exceptions.RetryError(f"Max retries exceeded with no successful response to {url}") \\n\\n    def _post(self, url: str, headers: dict[str, str], data: dict[str, Any], **kwargs) -> requests.Response:\\n        return self._request_with_retry(requests.post, url, headers, json=data, **kwargs) \\n\\n    def _get(self, url: str, headers: dict[str, str], **kwargs) -> requests.Response:\\n        return self._request_with_retry(requests.get, url, headers, **kwargs) \\n